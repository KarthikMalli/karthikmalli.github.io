<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Karthik Malli">

<title>LIS-572-Aut25</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="LIS572Project_files/libs/clipboard/clipboard.min.js"></script>
<script src="LIS572Project_files/libs/quarto-html/quarto.js"></script>
<script src="LIS572Project_files/libs/quarto-html/popper.min.js"></script>
<script src="LIS572Project_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="LIS572Project_files/libs/quarto-html/anchor.min.js"></script>
<link href="LIS572Project_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="LIS572Project_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="LIS572Project_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="LIS572Project_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="LIS572Project_files/libs/bootstrap/bootstrap-c0367b04c37547644fece4185067e4a7.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">LIS-572-Aut25</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Karthik Malli </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="lis-572-project-fall-25" class="level1">
<h1>LIS 572 Project, Fall ’25</h1>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>A key theme in my ongoing research is the circulation of texts and written material. More specifically, I look at these currents in India. Being in the US creates a disconnect between my physical location and the “field”, but there are still interesting sites of inquiry that present themselves when you least expect them.</p>
<p>Being on a university campus has made that abundantly clear. Many university libraries across the US, including the University of Washington (UW) library, have impressive collections of Indian language books, with rare collections often hard to source in India itself. Somehow, over 5000 miles away from where they were first printed, they sit contentedly on a shelf unnoticed by passers-by until once a decade, someone reads them.</p>
<p>But why are these books are here in the first place?</p>
</section>
<section id="food-for-books" class="level2">
<h2 class="anchored" data-anchor-id="food-for-books">“Food for Books”</h2>
<p>The answer lies (as it usually does) in the archives. Shortly after World War II, the United States Government undertook a novel scheme to procure books from newly independent countries across the world in exchange for foodstuffs. This was done to better understand potential allies (and foes) in the emerging geopolitical reconfigurations of the time. Termed the “food for books” program, the books procured through this scheme found their way into the libraries of American universities, including the University of Washington (UW). India was a major source for books, in the 1950s and 60s.</p>
<p>Many of the books procured under PL 480 were from India and formed the foundation of well-funded centers for the study of India and South Asia at universities like UChicago and UPenn. These universities continue to dominate academic research on South Asian themes, from history to linguistics to anthropology.</p>
</section>
<section id="library-collection" class="level2">
<h2 class="anchored" data-anchor-id="library-collection">Library Collection</h2>
<p>I began by reaching out to the South Asian Studies librarian at UW, Deepa Banerjee. I asked her if I could receive a dataset of UW’s books in Indian languages, which I limited to Hindi, Bengali, Urdu, Marathi, Kannada, Telugu, Malayalam, Tamil, Punjabi, Gujarati, and Sanskrit (yes, that’s a limited set). The data points I wanted were title, date of publication, publisher, date of acquisition, place of publication, language, and genre.</p>
<p>I chose the 11 languages of my focus from my knowledge of the primary literary languages of India in terms of literary output, population size, and newspaper readership. I felt it would be interesting to see what trends in acquisition exist along linguistic lines as a reflection of networks of book acquisition and academic interest.</p>
<p>Working with Deepa and Hana Levay, the collection assessment librarian, I received a large dataset containing all physical records at UW in these 11 languages. It had almost 10,000 entries!</p>
</section>
<section id="data-cleaning" class="level2">
<h2 class="anchored" data-anchor-id="data-cleaning">Data Cleaning</h2>
<p>Almost immediately, I encountered a major issue. I was informed that the data in the UW library system did not accurately record acquisition data from before 2013. This made it impossible with the given dataset to trace the direct imprint of PL 480 on the library collection and say definitively how many books in the UW collection were acquired this way.</p>
<p>I pivoted to instead looking at trends in language collection, and using date of publication as a proxy for date of acquisition (with the assumption that books would be acquired shortly after publication, and the obvious fact that books cannot be acquired _before_ they are published). I was also very interested in the spatial distribution of the collection: which cities in India, South Asia, and the world are these books from? After all, my definition of “Indian languages” included many transnational languages, like Urdu, Tamil, Bengali, Sanskrit, and Punjabi.</p>
<p>I also had to clean the data, since the city data used multiple transliteration schemes, and historical city names. For example, Dihli and Dilli both point to New Delhi; Cennai and Madras both point to Chennai; Poona and Punyanagar point to Pune. This, unfortunately, had to be done manually. I used OpenRefine for this (mindnumbing) task. I then “sliced” the data for the top 150 cities by book entries.</p>
<p>I also had to clean publication date data. The data included entries using three major non-Gregorian calendar styles: Hijri (~622), Fasli (~590), and Vikram Samvat (~56). Their Gregorian equivalent was supplied, in square brackets. To only capture the Gregorian entry, I had to devise a complex regex pattern that isolated dates from 1800-2000 and 2001-2025, which would definitively ignore Hijri and Fasli dates and VS dates greater than 2025.</p>
</section>
<section id="analysis" class="level2">
<h2 class="anchored" data-anchor-id="analysis">Analysis</h2>
<p>With that work done, I could move on to generating visualizations.</p>
<p>The most simple was a weighted bar graph of each of the 11 languages by book entry count, to see which languages are acquired more. Unsurprisingly, Hindi, Urdu, and Bengali top the list. I was somewhat surprised to see Malayalam at the bottom of the list, since it the language has a very robust publishing and reading culture in India, with a larger readership than languages with twice or even three times more speakers. This graph shows that the library collection reflects the visibility (and invisibility) of languages in US academia rather than their readership or publishing health.</p>
<p><iframe src="<a href=" https:="" github.com="" karthikmalli="" karthikmalli.github.io="" blob="" main="" uw-bar-line.html"="" title="UW-Bar-Line.html">UW-Bar-Line.html</a>" width="100%" height="500" style="border:none;"> </iframe></p>
<p>I created a line graph to see the volume of books in different languages across publication year, to get a sense of when books in the collection are from. I was surprised that it’s _after_ 2010 that the numbers are highest; I was expecting the 50s and 60s to be better represented. I was also surprised that there was little in the collection from the 1800s. Maybe UW was not a very substantial beneficiary of PL 480 after all.</p>
<p><iframe src="<a href=" https:="" github.com="" karthikmalli="" karthikmalli.github.io="" blob="" main="" uw-lang-line.html"="" title="UW-Lang-Line.html">UW-Lang-Line.html</a>" width="100%" height="500" style="border:none;"> </iframe></p>
<p>I was particularly excited to create a map of the collection using Leaflet, a library I had seen in the past and ended up playing around with on smaller side projects before this one (I also briefly read about in some technical readings for class). I used the cleaned city data with total book count for this, giving each city a circle marker weighted and colored by total book count to highlight the difference in volume.</p>
<p><iframe src="<a href=" https:="" github.com="" karthikmalli="" karthikmalli.github.io="" blob="" main="" uw-book-map.html"="" title="UW-Book-Map.html">UW-Book-Map.html</a>" width="100%" height="500" style="border:none;"> </iframe></p>
<p>Unsurprisingly, national and state/provincial capitals like Delhi, Lahore, Dhaka, and Chennai are overrepresented in the data. However, it was the smaller centers that I see as more interesting.</p>
<p>It was particularly gratifying to see how the map points represented well-documented nodes in literary production and traffic in different Indian languages, even if this importance was not reflected in their political status or demographic size. For example, Bijnor, a minor city with only ~115,000 people is the source of 35 books in the collection. The city, an important market town in British India, was once home to a thriving publishing industry in Urdu. Bareilly and Deoband, both in the same state of Uttar Pradesh, show up on the map for similar reasons. Any scholar of Urdu would see the small dots on the landscape of northern India and immediately make this connection.</p>
<p>It was funny to see distant Osnabrück in Germany show up on the map too…</p>
</section>
<section id="some-issues" class="level2">
<h2 class="anchored" data-anchor-id="some-issues">Some Issues</h2>
<p>It’s important to note that the data I worked with is not publicly available or viewable, but students at UW can request library data from librarians in a similar process to my own. This will likely not be an option for people who are neither students nor staff at UW. My presence within the university system affords me this opportunity that researchers back in India itself cannot make use of. This is unfortunately an infrastructural issue that scholars from non-Western countries in Western academia are all too familiar with, and it sustains a system of knowledge asymmetry.</p>
</section>
<section id="whats-next" class="level2">
<h2 class="anchored" data-anchor-id="whats-next">What’s Next?</h2>
<p>As a larger project, I would be super interested in doing a similar analysis across major US university libraries, to see if there are discernable trends in what languages or regions are better represented where, or if certain decades show more acquisition rates than others. I am also curious if there is another way to find the elusive 1950s-1960s data – perhaps other libraries have it – and see once and for all what books were acquired under PL 480 and what genres they represent. Perhaps their choices represent what was deemed geopolitically significant at the time, or maybe it was just whatever was being offloaded by Indian publishers.</p>
<p>With that, we’re back to the question: what books are people reading, and where do they come from?</p>
<p>I’d like to let these visualizations try and answer that, if even only in part.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>